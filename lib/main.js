// Generated by CoffeeScript 1.10.0
(function() {
  var $, $async, CND, D, HOLLERITH, alert, badge, copy, debug, echo, f, help, hide, info, is_hidden, is_stamped, log, njs_fs, njs_path, rpr, select, stamp, step, suspend, unstamp, urge, warn, whisper,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  njs_path = require('path');

  njs_fs = require('fs');

  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'MK/TS/JIZURA/main';

  log = CND.get_logger('plain', badge);

  info = CND.get_logger('info', badge);

  whisper = CND.get_logger('whisper', badge);

  alert = CND.get_logger('alert', badge);

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  echo = CND.echo.bind(CND);

  suspend = require('coffeenode-suspend');

  step = suspend.step;

  D = require('pipedreams');

  $ = D.remit.bind(D);

  $async = D.remit_async.bind(D);

  hide = MK.TS.MD_READER.hide.bind(MK.TS.MD_READER);

  copy = MK.TS.MD_READER.copy.bind(MK.TS.MD_READER);

  stamp = MK.TS.MD_READER.stamp.bind(MK.TS.MD_READER);

  unstamp = MK.TS.MD_READER.unstamp.bind(MK.TS.MD_READER);

  select = MK.TS.MD_READER.select.bind(MK.TS.MD_READER);

  is_hidden = MK.TS.MD_READER.is_hidden.bind(MK.TS.MD_READER);

  is_stamped = MK.TS.MD_READER.is_stamped.bind(MK.TS.MD_READER);

  HOLLERITH = null;


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  f = function() {
    return this.remit_async_spread = function(method) {
      var $call, $spread, Z, arity, input, output;
      if ((arity = method.length) !== 2) {
        throw new Error("expected a method with an arity of 2, got one with an arity of " + arity);
      }
      Z = [];
      input = this.create_throughstream();
      output = this.create_throughstream();
      $call = (function(_this) {
        return function() {
          return $async(function(event, done) {
            var collect;
            collect = function(data) {
              Z.push(data);
              return null;
            };
            collect.done = function(data) {
              if (data != null) {
                collect(data);
              }
              done(Object.assign([], Z));
              return Z.length = 0;
            };
            method(event, collect);
            return null;
          });
        };
      })(this);
      $spread = (function(_this) {
        return function() {
          return $(function(collection, send, end) {
            var event, i, len;
            if (collection != null) {
              for (i = 0, len = collection.length; i < len; i++) {
                event = collection[i];
                send(event);
              }
            }
            if (end != null) {
              return end();
            }
          });
        };
      })(this);
      input.pipe($call()).pipe($spread()).pipe(output);
      return this.TEE.from_readwritestreams(input, output);
    };
  };

  f.apply(D);


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */


  /*  * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # */

  this._provide_db = function(S) {
    var db_route;
    HOLLERITH = require('hollerith');
    db_route = njs_path.resolve(__dirname, '../../jizura-datasources/data/leveldb-v2');
    if (S.JZR == null) {
      S.JZR = {};
    }
    if (S.JZR.db != null) {
      help("re-using DB connection to DB at " + db_route);
    } else {
      warn("establishing new DB connection to DB at " + db_route);
      S.JZR.db = HOLLERITH.new_db(db_route, {
        create: false
      });
    }
    return null;
  };

  this.$main = (function(_this) {
    return function(S) {
      return D.TEE.from_pipeline([_this.$fontlist(S), _this.$vertical_bar_divider(S), _this.$most_frequent.with_fncrs.$rewrite_events(S), _this.$dump_db(S), _this.$most_frequent.$read(S), _this.$most_frequent.$assemble(S), _this.$most_frequent.$details_from_glyphs(S), _this.$most_frequent.with_fncrs.$format(S), _this.$most_frequent.with_fncrs.$assemble(S), _this.$dump_db.$format(S), _this.$py(S)]);
    };
  })(this);

  this.$fontlist = (function(_this) {
    return function(S) {
      var _X_glyphs, cid, kaishu_shortnames, kana_shortnames, template;
      kaishu_shortnames = ['Fandolkairegular', 'Kai', 'Ukai', 'Epkaisho', 'Cwtexqkaimedium', 'Biaukai'];
      kana_shortnames = ['Babelstonehan', 'Cwtexqfangsongmedium', 'Cwtexqheibold', 'Cwtexqkaimedium', 'Cwtexqmingmedium', 'Cwtexqyuanmedium', 'Hanamina', 'Sunexta', 'Kai', 'Nanumgothic', 'Nanummyeongjo', 'Simsun', 'Fandolfangregular', 'Fandolheibold', 'Fandolheiregular', 'Fandolkairegular', 'Fandolsongbold', 'Fandolsongregular', 'Ipaexg', 'Ipaexm', 'Ipag', 'Ipagp', 'Ipam', 'Ipamp', 'Ipaexg', 'Ipaexm', 'Ipag', 'Ipagp', 'Ipam', 'Ipamp', 'Ukai', 'Uming', 'Droidsansfallbackfull', 'Droidsansjapanese', 'Fontsjapanesegothic', 'Fontsjapanesemincho', 'Takaopgothic', 'Sourcehansansbold', 'Sourcehansansextralight', 'Sourcehansansheavy', 'Sourcehansanslight', 'Sourcehansansmedium', 'Sourcehansansnormal', 'Sourcehansansregular'];
      template = "($shortname) {\\($texname){\\cjk\\($texname){}ぁあぃいぅうぇえぉおかがきぎく\nぐけげこごさざしじすずせぜそぞた\nだちぢっつづてでとどなにぬねのは\nばぱひびぴふぶぷへべぺほぼぽまみ\nむめもゃやゅゆょよらりるれろゎわ\nゐゑをんゔゕゖァアィイゥウェエォオカガキギク\nグケゲコゴサザシジスズセゼソゾタ\nダチヂッツヅテデトドナニヌネノハ\nバパヒビピフブプヘベペホボポマミ\nムメモャヤュユョヨラリルレロヮワ\nヰヱヲンヴヵヶヷヸヹヺ\n本书使用的数字，符号一览表}\nAaBbCcDdEeFfghijklmn}";
      template = "This is {\\cjk\\($texname){}むず·かしい} so very {\\cjk\\($texname){}ムズ·カシイ} indeed.";
      template = "XXX{\\($texname){}·}XXX";
      template = "The character {\\cjk{}出} {\\($texname){}u{\\mktsFontfileEbgaramondtwelveregular{}·}cjk{\\mktsFontfileEbgaramondtwelveregular{}·}51fa} means '{\\mktsStyleItalic{}go out, send out, stand, produce}'.";
      template = "{\\($texname){}出 、出。出〃出〄出々出〆出〇出〈出〉出《出》出「出」出}\\\\\n\\> {\\($texname){}出『出』出【出】出〒出〓出〔出〕出〖出〗出〘出〙出〚出}";
      template = "{\\($texname){}abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}";
      template = "{\\($texname){\\cjk\\($texname){}≈∫🞛🞁▲●⋮⊥「本」书使用的数字，符号一览表書覽} AaBbCcDdEeFfghijklmnopqrstuvwxyz}";
      template = "{\\mktsStyleNormal{}How vexingly quick daft zebras jump!} {\\($texname){}How vexingly quick daft zebras jump!} {\\mktsStyleItalic{}How vexingly quick daft zebras jump!}";
      template = "{\\mktsStyleNormal{}How vexingly quick fäöüß} {\\($texname){}How vexingly quick fäöüß} {\\mktsStyleItalic{}How vexingly quick fäöüß}";
      template = "{\\cjk\\($texname){}春 ⿱𡗗日}";
      template = "{\\($texname){}𝒜ℬ𝒞𝒟ℰℱ𝒢ℋℐ𝒥𝒦ℒℳ𝒩𝒪𝒫𝒬ℛ𝒮𝒯𝒰𝒱𝒲𝒳𝒴𝒵}\\\\\n\\> {\\($texname){}𝒶𝒷𝒸𝒹ℯ𝒻ℊ𝒽𝒾𝒿𝓀𝓁𝓂𝓃ℴ𝓅𝓆𝓇𝓈𝓉𝓊𝓋𝓌𝓍𝓎𝓏}\\\\\n\\> {\\($texname){}𝓐𝓑𝓒𝓓𝓔𝓕𝓖𝓗𝓘𝓙𝓚𝓛𝓜𝓝𝓞𝓟𝓠𝓡𝓢𝓣𝓤𝓥𝓦𝓧𝓨𝓩}\\\\\n\\> {\\($texname){}𝓪𝓫𝓬𝓭𝓮𝓯𝓰𝓱𝓲𝓳𝓴𝓵𝓶𝓷𝓸𝓹𝓺𝓻𝓼𝓽𝓾𝓿𝔀𝔁𝔂𝔃}";
      _X_glyphs = ((function() {
        var i, results;
        results = [];
        for (cid = i = 0x20000; i <= 131327; cid = ++i) {
          results.push(String.fromCodePoint(cid));
        }
        return results;
      })()).join('');
      template = "{\\cjk\\($texname){}⺝" + _X_glyphs + "}";
      template = "{\\cjk\\($texname){}x←xx→x↑x↓x↔x↕x🡐x🡒x🡑x🡓x🡔x🡕x🡖x🡗x🡘x🡙}";
      template = "{\\($texname){}カタカナ片仮名ひらがな平仮名}";
      template = "{\\($texname){}├── xxxxxxx}\\\\\n\\> {\\($texname){}│   ├── xxxxxxx}\\\\";
      template = "{\\($texname){}⤾⤶↵ ↫}";
      template = "{\\($texname){}▷}";
      template = "{\\($texname) AaBbCcDdEeFfghijklmnopqrstuvwxyz {\\cjk\\($texname){}永東國酬愛鬱靈鷹袋南去經三國，東來過五湖东国爱郁灵鹰经来过}}";
      return $(function(event, send) {
        var i, len, raw, ref, shortname, texname;
        if (select(event, '!', 'JZR.fontlist')) {
          send(stamp(event));
          send(['tex', "\\begin{tabbing}\n"]);
          send(['tex', "\\phantom{XXXXXXXXXXXXXXXXXXXXXXXXX} \\= \\phantom{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX} \\\\\n"]);
          ref = S.options['fonts']['files'];
          for (i = 0, len = ref.length; i < len; i++) {
            texname = ref[i].texname;
            shortname = texname.replace(/^mktsFontfile/, '');
            raw = template;
            raw = raw.replace(/\(\$texname\)/g, texname);
            raw = raw.replace(/\(\$shortname\)/g, shortname);
            send(['tex', shortname + " \\> " + raw + " \\\\\n"]);
          }
          return send(['tex', "\\end{tabbing}\n"]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$most_frequent = {};

  this.$most_frequent.with_fncrs = {};

  this.$most_frequent.with_fncrs.$rewrite_events = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var _, meta, parameters;
        if (select(event, '!', 'JZR.most_frequent.with_fncrs')) {
          _ = event[0], _ = event[1], parameters = event[2], meta = event[3];
          if (meta['jzr'] == null) {
            meta['jzr'] = {};
          }
          meta['jzr']['group-name'] = 'glyphs-with-fncrs';
          return send(['!', 'JZR.most_frequent', parameters, meta]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$most_frequent.$read = (function(_this) {
    return function(S) {
      var defaults;
      defaults = {
        n: 100,
        group_name: 'glyphs'
      };
      return D.remit_async_spread(function(event, send) {
        var HOLLERITH_DEMO, group_name, meta, n, name, ref, ref1, ref2, type;
        if (!select(event, '!', 'JZR.most_frequent')) {
          return send.done(event);
        }
        HOLLERITH_DEMO = require('../../hollerith/lib/demo');
        type = event[0], name = event[1], (ref = event[2], n = ref[0]), meta = event[3];
        if (n == null) {
          n = defaults.n;
        }
        group_name = (ref1 = (ref2 = meta['jzr']) != null ? ref2['group-name'] : void 0) != null ? ref1 : defaults.group_name;
        return step(function*(resume) {
          var error, error1, glyph, glyphs, i, len;
          try {
            _this._provide_db(S);
            glyphs = (yield HOLLERITH_DEMO.read_sample(S.JZR.db, n, resume));
          } catch (error1) {
            error = error1;
            warn(error);
            return send.error(error);
          }
          send(stamp(event));
          glyphs = Object.keys(glyphs);
          send(['(', group_name, null, copy(meta)]);
          for (i = 0, len = glyphs.length; i < len; i++) {
            glyph = glyphs[i];
            send(['.', 'glyph', glyph, copy(meta)]);
          }
          send([')', group_name, null, copy(meta)]);
          return send.done();
        });
      });
    };
  })(this);

  this.$most_frequent.$assemble = (function(_this) {
    return function(S) {
      var track;
      track = MK.TS.MD_READER.TRACKER.new_tracker('(glyphs)');
      return $(function(event, send) {
        var _, glyph, meta, within_glyphs;
        within_glyphs = track.within('(glyphs)');
        track(event);
        if (select(event, '(', 'glyphs')) {
          return send(stamp(event));
        } else if (within_glyphs && select(event, '.', 'glyph')) {
          _ = event[0], _ = event[1], glyph = event[2], meta = event[3];
          return send(['.', 'text', glyph, copy(meta)]);
        } else if (select(event, ')', 'glyphs')) {
          return send(stamp(event));
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$most_frequent.$details_from_glyphs = (function(_this) {
    return function(S) {
      return D.remit_async_spread(function(event, send) {
        var _, glyph, meta, prefix;
        if (select(event, '.', 'glyph')) {
          _ = event[0], _ = event[1], glyph = event[2], meta = event[3];
          prefix = ['spo', glyph];
          _this._provide_db(S);
          return HOLLERITH.read_phrases(S.JZR.db, {
            prefix: prefix
          }, function(error, phrases) {
            var details, i, len, obj, phrase, prd;
            details = {
              glyph: glyph
            };
            for (i = 0, len = phrases.length; i < len; i++) {
              phrase = phrases[i];
              _ = phrase[0], _ = phrase[1], prd = phrase[2], obj = phrase[3];
              details[prd] = obj;
            }
            send(['.', 'details', details, copy(meta)]);
            return send.done();
          });
        } else {
          return send.done(event);
        }
      });
    };
  })(this);

  this.$most_frequent.with_fncrs.$format = (function(_this) {
    return function(S) {
      var has_gloss, has_readings, reading_keys, this_glyph, track;
      track = MK.TS.MD_READER.TRACKER.new_tracker('(glyphs-with-fncrs)');
      this_glyph = null;
      reading_keys = ['reading/py', 'reading/hg', 'reading/ka', 'reading/hi'];
      has_readings = function(x) {
        return (CND.isa_list(x)) && (x.length > 0);
      };
      has_gloss = function(x) {
        return (CND.isa_text(x)) && (x.length > 0);
      };
      return $(function(event, send) {
        var _, details, gloss, i, len, meta, prd, reading, readings, within_glyphs;
        within_glyphs = track.within('(glyphs-with-fncrs)');
        track(event);
        if (within_glyphs && select(event, '.', 'details')) {
          _ = event[0], _ = event[1], details = event[2], meta = event[3];
          for (i = 0, len = reading_keys.length; i < len; i++) {
            prd = reading_keys[i];
            if (has_readings((readings = details[prd]))) {
              if (prd === 'reading/ka' || prd === 'reading/hi') {
                readings = (function() {
                  var j, len1, results;
                  results = [];
                  for (j = 0, len1 = readings.length; j < len1; j++) {
                    reading = readings[j];
                    results.push(reading.replace(/-/g, '⋯'));
                  }
                  return results;
                })();
              }
              details[prd] = readings.join(', \n');
            }
          }
          if (has_gloss((gloss = details['reading/gloss']))) {
            details['reading/gloss'] = gloss.replace(/;/g, ',');
          }
          return send(event);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$most_frequent.with_fncrs.$assemble = (function(_this) {
    return function(S) {
      var this_glyph, track;
      track = MK.TS.MD_READER.TRACKER.new_tracker('(glyphs-with-fncrs)');
      this_glyph = null;
      return $(function(event, send) {
        var _, count, details, glyph, i, infix, key, len, meta, prefix, ref, suffix, text, value, value_txt, within_glyphs;
        within_glyphs = track.within('(glyphs-with-fncrs)');
        track(event);
        if (select(event, '(', 'glyphs-with-fncrs')) {
          _ = event[0], _ = event[1], this_glyph = event[2], _ = event[3];
          send(stamp(event));
          return send(['tex', '{\\setlength\\parskip{0mm}\n']);
        } else if (select(event, ')', 'glyphs-with-fncrs')) {
          this_glyph = null;
          send(stamp(event));
          return send(['tex', '}\n\n']);
        } else if (within_glyphs && select(event, '.', 'details')) {
          _ = event[0], _ = event[1], details = event[2], meta = event[3];
          send(['tex', "\\begin{tabular}{ | @{} p{20mm} @{} | @{} l @{} | @{} p{1mm} @{} | @{} p{60mm} @{} | }\n"]);
          value = details['guide/kwic/v3/sortcode'];
          value = value[0];
          _ = value[0], infix = value[1], suffix = value[2], prefix = value[3];
          value = infix + suffix.join('');
          send(['.', 'text', value, copy(meta)]);
          send(['tex', " & "]);
          glyph = details['glyph'];
          send(['tex', "{\\mktsStyleMidashi{}\\sbSmash{"]);
          send(['.', 'text', "" + glyph, copy(meta)]);
          send(['tex', "}}"]);
          send(['tex', " & "]);
          send(['tex', "{\\color{white} | |}"]);
          send(['tex', " & "]);
          value = details['formula'];
          if ((value != null) && value.length > 0) {
            value = value[0];
            send(['.', 'text', value, copy(meta)]);
          }
          value = details['cp/fncr'];
          value = value.replace(/-/g, '·');
          send(['tex', "{\\mktsStyleFncr{}"]);
          send(['.', 'text', value, copy(meta)]);
          send(['tex', "}\n"]);
          count = 0;
          ref = ['reading/py', 'reading/hg', 'reading/ka', 'reading/hi', 'reading/gloss'];
          for (i = 0, len = ref.length; i < len; i++) {
            key = ref[i];
            value = details[key];
            if (value == null) {
              continue;
            }
            value_txt = CND.isa_text(value) ? value : rpr(value);
            text = "" + value_txt;
            if (count !== 0) {
              send(['.', 'text', '; \n', copy(meta)]);
            }
            if (key === 'reading/gloss') {
              send(['tex', "{\\mktsStyleGloss{}"]);
            }
            send(['.', 'text', text, copy(meta)]);
            if (key === 'reading/gloss') {
              send(['tex', "}"]);
            }
            count += +1;
          }
          if (count !== 0) {
            send(['.', 'text', '.', copy(meta)]);
          }
          if ((value = details['variant']) != null) {
            value = value.join('');
            send(['.', 'text', " " + value, copy(meta)]);
          }
          send(['tex', "\\\\\n\\hline\n"]);
          send(['tex', "\\end{tabular}\n"]);
          return send(['.', 'p', null, copy(meta)]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$dump_db = (function(_this) {
    return function(S) {
      return $(function(event, send) {
        var _, glyph, glyphs, i, len, meta, parameters, settings, tasks;
        if (select(event, '!', 'JZR.dump_db')) {
          _ = event[0], _ = event[1], parameters = event[2], meta = event[3];
          settings = parameters[0];
          if ((glyphs = settings['glyphs']) != null) {
            if (CND.isa_text(glyphs)) {
              glyphs = MK.TS.XNCHR.chrs_from_text(glyphs);
            }
            tasks = [];
            send(['(', 'dump-db', glyphs, copy(meta)]);
            for (i = 0, len = glyphs.length; i < len; i++) {
              glyph = glyphs[i];
              send(['.', 'glyph', glyph, copy(meta)]);
            }
            return send([')', 'dump-db', glyphs, copy(meta)]);
          } else {
            return send(['.', 'warning', "expected setting 'glyphs' in call to `JZR.dump_db`", copy(meta)]);
          }
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$dump_db.$format = (function(_this) {
    return function(S) {
      var excludes, track;
      track = MK.TS.MD_READER.TRACKER.new_tracker('(dump-db)');
      excludes = ['guide/kwic/v1/lineup/wrapped/infix', 'guide/kwic/v1/lineup/wrapped/prefix', 'guide/kwic/v1/lineup/wrapped/single', 'guide/kwic/v1/lineup/wrapped/suffix', 'guide/kwic/v1/sortcode', 'guide/kwic/v2/lineup/wrapped/single', 'guide/kwic/v2/sortcode'];
      return $(function(event, send) {
        var _, details, glyph, idx, last_idx, meta, predicate, value, value_txt, within_dumpdb;
        within_dumpdb = track.within('(dump-db)');
        track(event);
        if (within_dumpdb && select(event, '.', 'details')) {
          _ = event[0], _ = event[1], details = event[2], meta = event[3];
          send(stamp(event));
          glyph = details.glyph;
          delete details['glyph'];
          last_idx = (Object.keys(details)).length - 1;
          idx = -1;
          send(['.', 'p', null, copy(meta)]);
          send(['.', 'text', "Details for Glyph " + glyph + " " + details['cp/fncr'], copy(meta)]);
          send(['.', 'p', null, copy(meta)]);
          for (predicate in details) {
            value = details[predicate];
            idx += +1;
            if (indexOf.call(excludes, predicate) >= 0) {
              continue;
            }
            value_txt = JSON.stringify(value, null, ' ');
            send(['tex', "\\begin{tabular}{ | p{30mm} | p{129mm} | }\n"]);
            if (idx === 0) {
              send(['tex', "\\hline\n"]);
            }
            send(['tex', "{\\mktsStyleFontUrl{}"]);
            send(['.', 'text', "" + predicate, copy(meta)]);
            send(['tex', "}"]);
            send(['tex', " & ", copy(meta)]);
            send([
              '.', 'text', "" + value_txt, copy(meta, {
                'typofix': 'escape-ncrs'
              })
            ]);
            send(['tex', "\\\\\n", copy(meta)]);
            if (idx === last_idx) {
              send(['tex', "\\hline\n"]);
            }
            send(['tex', "\\end{tabular}\n"]);
          }
          return send(['.', 'p', null, copy(meta)]);
        } else if (select(event, '(', 'dump-db')) {
          return send(stamp(event));
        } else if (select(event, ')', 'dump-db')) {
          return send(stamp(event));
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$py = (function(_this) {
    return function(S) {

      /* TAINT should translate special syntax to ordinary commands, then translate to TeX */

      /* TAINT make RegEx more specific, don't include punctuation */
      var compile_pinyin, py_pattern;
      py_pattern = /!py!([^\s]+)/;
      compile_pinyin = function(text) {
        return text.replace(py_pattern, function($0, $1) {

          /* TAINT translate digits to accents */

          /* TAINT consider to use fix_typography_for_tex */
          return "{\\py{}" + $1 + "}";
        });
      };
      return $(function(event, send) {
        var meta, name, text, type;
        type = event[0], name = event[1], text = event[2], meta = event[3];
        if (select(event, '(', 'py')) {
          send(stamp(event));
          return send(['tex', "{\\py{}"]);
        } else if (select(event, ')', 'py')) {
          send(stamp(event));
          return send(['tex', "}"]);
        } else if (select(event, '.', 'text')) {
          return send(['.', 'text', compile_pinyin(text), copy(meta)]);
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$vertical_bar_braces = (function(_this) {
    return function(S) {
      var matcher, use_vertical_bar;
      use_vertical_bar = false;
      matcher = /([「【】」^]|\.\.\.)/g;
      return $(function(event, send) {
        var chunk, chunks, i, len, meta, name, results, text, type;
        debug('0001', event);
        if (select(event, ['!', '('], 'JZR.vertical-bar')) {
          send(stamp(event));
          return use_vertical_bar = true;
        } else if (select(event, ')', 'JZR.vertical-bar')) {
          send(stamp(event));
          return use_vertical_bar = false;
        } else if (use_vertical_bar && select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          chunks = text.split(matcher);
          results = [];
          for (i = 0, len = chunks.length; i < len; i++) {
            chunk = chunks[i];
            switch (chunk) {
              case '【':
              case '】':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\mktsJzrVerticalbarInfix{}"]));
                break;
              case '「':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\mktsJzrGlyphbraceLeft{}"]));
                break;
              case '」':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\mktsJzrGlyphbraceRight{}"]));
                break;
              case '...':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\hrulefill{}"]));
                break;
              case '^':
                results.push(send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)]))));
                break;
              default:
                results.push(send(['.', 'text', chunk, copy(meta)]));
            }
          }
          return results;
        } else {
          return send(event);
        }
      });
    };
  })(this);

  this.$vertical_bar_divider = (function(_this) {
    return function(S) {
      var matcher, use_vertical_bar;
      use_vertical_bar = false;
      matcher = /(\||【|】|」|「|——\.|\.——|\^|==>)/g;
      return $(function(event, send) {
        var chunk, chunks, i, len, meta, name, results, text, type;
        if (select(event, ['!', '('], 'JZR.vertical-bar')) {
          send(stamp(event));
          return use_vertical_bar = true;
        } else if (select(event, ')', 'JZR.vertical-bar')) {
          send(stamp(event));
          return use_vertical_bar = false;
        } else if (use_vertical_bar && select(event, '.', 'text')) {
          type = event[0], name = event[1], text = event[2], meta = event[3];
          chunks = text.split(matcher);
          results = [];
          for (i = 0, len = chunks.length; i < len; i++) {
            chunk = chunks[i];
            switch (chunk) {
              case '【':
              case '】':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\mktsJzrVerticalbarInfix{}"]));
                break;
              case '|':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\mktsJzrVerticalbarGlyph{}"]));
                break;
              case '」「':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\mktsJzrGlyphdivider{}"]));
                break;
              case '——.':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "{\\tfRaise{0.3}\\mktsHrulefill{1}}\u2004\u2004"]));
                break;
              case '.——':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\u2004\u2004{\\tfRaise{0.3}\\mktsHrulefill{1}}"]));
                break;
              case '==>':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\hfill{}"]));
                break;
              case '^':
                send(hide(stamp(['#', 'vertical-bar', chunk, copy(meta)])));
                results.push(send(['tex', "\\hfill{}{\\mktsFontfileEbgaramondtwelveregular{}↑}"]));
                break;
              default:
                results.push(send(['.', 'text', chunk, copy(meta)]));
            }
          }
          return results;
        } else {
          return send(event);
        }
      });
    };
  })(this);

}).call(this);

//# sourceMappingURL=main.js.map
